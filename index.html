<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ù…Ø´ØºÙ„ ÙÙŠØ¯ÙŠÙˆ + Ù…Ù„Ø®Øµ Ø°ÙƒÙŠ + Ù…Ù„Ø§Ø­Ø¸Ø§Øª ÙˆØµÙˆØ± + ØªØ±ØªÙŠØ¨ ÙŠØ¯ÙˆÙŠ</title>
  <style>
    /* --- Ø§Ù„Ø£Ù†Ù…Ø§Ø· CSS --- */
     body {
      text-align: right;
      font-family: 'Arial', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f9f9f9;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }
    #videoContainer, #summaryBox, #transcriptInput, .search-box, .notes-section, .lecture-images-section {
      width: 90%;
      max-width: 900px;
      margin: 15px auto;
      text-align: right;
      font-size: 16px;
      line-height: 1.8;
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
    }
    textarea {
      width: 100%;
      height: 150px;
      font-size: 16px;
      padding: 12px;
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      transition: background-color 0.3s, color 0.3s;
      font-family: 'Arial', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-align: right;
      direction: rtl;
      box-sizing: border-box;
      white-space: pre-wrap; /* Preserve whitespace and wrap */
      word-wrap: break-word; /* Break long words */
    }
    input[type="text"] {
      width: 70%;
      padding: 12px;
      margin: 8px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 16px;
      font-family: 'Arial', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-align: right;
      direction: rtl;
      box-sizing: border-box;
    }
    .control-btn, .record-btn {
      padding: 12px 20px;
      margin: 5px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #007bff;
      color: white;
      transition: 0.3s;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      font-family: 'Arial', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      vertical-align: middle;
    }
    .control-btn:hover, .record-btn:hover {
      background-color: #0056b3;
    }
    .record-btn.recording {
      background-color: #dc3545;
    }
    .record-btn.recording:hover {
      background-color: #c82333;
    }
    iframe {
      width: 100%;
      height: 450px;
      border-radius: 8px;
      border: none;
    }
    .floating-controls {
      position: fixed;
      bottom: 25px;
      left: 25px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1000;
    }
    .floating-right-controls {
      position: fixed;
      bottom: 25px;
      right: 25px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1000;
    }
    #notesList {
      list-style-type: none;
      padding: 0;
      width: 90%;
      max-width: 900px;
      margin: 20px auto;
    }
    #notesList li {
      background-color: #fff;
      padding: 15px;
      margin-bottom: 10px;
      border-radius: 5px;
      box-shadow: 0px 1px 3px rgba(0,0,0,0.1);
      text-align: right;
      font-size: 15px;
      line-height: 1.6;
      overflow-wrap: break-word;
      word-wrap: break-word; /* Fallback for older browsers */
      white-space: pre-wrap; /* Ensure text wraps naturally preserving whitespace */
      position: relative;
      display: flex;
      align-items: flex-start; /* Align items to the top */
      user-select: none;
      flex-direction: column; /* Stack content and buttons vertically */
    }
    #notesList li audio {
        width: 100%;
        max-width: 300px;
        margin-top: 10px;
        vertical-align: middle;
        margin-left: 10px;
    }
    .speed-controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }
    .speed-btn {
      min-width: 65px;
      padding: 12px;
    }
    .clear-search-btn {
      padding: 12px 18px;
      margin: 10px;
      font-size: 15px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #dc3545;
      color: white;
      transition: 0.3s;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      font-family: 'Arial', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      vertical-align: middle;
    }
    .clear-search-btn:hover {
      background-color: #c82333;
    }
     /* Smaller buttons inside notes list */
     #notesList .control-btn, #notesList .clear-search-btn {
        padding: 3px 8px;
        font-size: 13px;
        margin-right: 5px;
        vertical-align: middle;
        margin-top: 5px;
     }
     #notesList li b {
        font-weight: bold;
        color: #007bff;
        margin-left: 5px;
        display: inline; /* Allow timestamp to be inline with text */
     }
     .note-content {
         flex-grow: 1;
         width: 100%; /* Allow content to take full width */
     }
     .reorder-buttons {
         display: flex;
         flex-direction: column;
         margin-left: auto; /* Push to the right (in RTL) */
         gap: 2px;
     }
     .reorder-buttons button {
         padding: 2px 5px;
         font-size: 10px;
         cursor: pointer;
         background-color: #6c757d;
         color: white;
         border: none;
         border-radius: 3px;
         transition: 0.3s;
     }
     .reorder-buttons button:hover {
         background-color: #5a6268;
     }
     /* Styles for buttons below note text/audio */
     .note-buttons-container {
         display: flex;
         justify-content: flex-end; /* Align buttons to the left (in RTL) */
         margin-top: 8px; /* Space above buttons */
         padding-right: 10px; /* Shift buttons slightly to the left (in RTL) */
     }
     .note-buttons-container button {
         margin-left: 5px; /* Space between buttons */
     }


    /* Dark Mode Styles */
    .dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }
    .dark-mode #videoContainer,
    .dark-mode #summaryBox,
    .dark-mode #transcriptInput,
    .dark-mode .search-box,
    .dark-mode .notes-section,
    .dark-mode .lecture-images-section {
      background-color: #1e1e1e;
      color: #e0e0e0;
      border: 1px solid #333;
    }
    .dark-mode textarea {
      background-color: #2d2d2d;
      color: #e0e0e0;
      border: 1px solid #444;
    }
    .dark-mode input[type="text"] {
      background-color: #2d2d2d;
      color: #e0e0e0;
      border: 1px solid #444;
    }
    .dark-mode .control-btn, .dark-mode .record-btn {
      background-color: #444;
      color: #fff;
    }
    .dark-mode .control-btn:hover, .dark-mode .record-btn:hover {
      background-color: #555;
    }
    .dark-mode .record-btn.recording {
        background-color: #a71d2a;
    }
    .dark-mode .record-btn.recording:hover {
        background-color: #8c1a24;
    }
    .dark-mode #notesList li {
      background-color: #2d2d2d;
      color: #e0e0e0;
      border: 1px solid #444;
    }
     .dark-mode #notesList li b {
        color: #4dabf7;
     }
    .dark-mode .clear-search-btn {
      background-color: #a71d2a;
    }
    .dark-mode .clear-search-btn:hover {
      background-color: #8c1a24;
    }
     .dark-mode #notesList li audio {
         filter: invert(1) hue-rotate(180deg);
     }
     .dark-mode .reorder-buttons button {
         background-color: #555;
     }
      .dark-mode .reorder-buttons button:hover {
          background-color: #777;
      }

    /* Highlight Styles */
    .highlight {
      background-color: yellow;
      color: black;
      padding: 0 3px;
      border-radius: 3px;
    }
    .highlight-line {
      background-color: rgba(255, 255, 0, 0.3);
      border-left: 4px solid yellow;
      padding: 10px;
      margin: 10px 0;
      cursor: pointer;
      border-radius: 0 6px 6px 0;
      position: relative;
    }
     .highlight-line .control-btn {
        padding: 2px 6px !important;
        font-size: 12px !important;
        float: left;
        margin-left: 5px;
        position: absolute;
        left: 5px;
        top: 50%;
        transform: translateY(-50%);
     }
    .highlight-line:hover {
      background-color: rgba(255, 255, 0, 0.5);
    }
    .dark-mode .highlight-line {
        background-color: rgba(255, 255, 0, 0.2);
        border-left-color: #ffd700;
    }
    .dark-mode .highlight-line:hover {
        background-color: rgba(255, 255, 0, 0.3);
    }

    /* Summary Box Styles */
    #summaryBox {
      text-align: right;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Arial', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.8;
      padding: 20px;
      overflow-wrap: break-word;
      min-height: 100px;
    }
    #summaryBox b { font-weight: bold; color: #007bff; }
    .dark-mode #summaryBox b { color: #4dabf7; }
    #summaryBox i { font-style: italic; }
    #summaryBox u { text-decoration: underline; }
    #summaryBox h2, #summaryBox h3, #summaryBox h4 {
        margin-top: 1.5em; margin-bottom: 0.5em; color: #0056b3;
        border-bottom: 1px solid #eee; padding-bottom: 0.3em;
    }
    .dark-mode #summaryBox h2, .dark-mode #summaryBox h3, .dark-mode #summaryBox h4 {
        color: #66d9e8; border-bottom-color: #444;
    }
    #summaryBox ul, #summaryBox ol { padding-right: 20px; margin-bottom: 1em; }
    #summaryBox code { background-color: #e9ecef; padding: 2px 5px; border-radius: 3px; font-family: monospace; color: #333; direction: ltr; display: inline-block;}
    .dark-mode #summaryBox code { background-color: #3a3a3a; color: #f0f0f0; }
    .note-link { color: #007bff; cursor: pointer; text-decoration: underline; }
    .dark-mode .note-link { color: #4dabf7; }

    /* LaTeX Styles */
    .latex {
      color: #d63384; font-family: "Courier New", monospace;
      background-color: rgba(214, 51, 132, 0.1); padding: 2px 8px;
      border-radius: 4px; font-size: 1.1em; direction: ltr; display: inline-block;
      vertical-align: middle;
    }
    .math-container {
      margin: 20px 0; padding: 15px; background-color: rgba(248, 249, 250, 0.8);
      border-radius: 6px; border-right: 5px solid #d63384; border-left: none;
      overflow-x: auto; text-align: center; direction: ltr;
    }
    .dark-mode .latex { color: #ff6b9e; background-color: rgba(255, 107, 158, 0.1); }
    .dark-mode .math-container { background-color: rgba(30, 30, 30, 0.8); border-right-color: #ff6b9e; }

    /* Image Gallery Styles */
    #imageGallery { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 15px; }
    #imageGallery .img-container { position: relative; display: inline-block; border: 1px solid #ddd; border-radius: 5px; overflow: hidden; }
     .dark-mode #imageGallery .img-container { border: 1px solid #444; }

    #imageGallery img {
        display: block; width: 120px; height: 120px; object-fit: cover;
        cursor: pointer; transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    }
    #imageGallery img:hover { transform: scale(1.05); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    #imageGallery .delete-img-btn {
        position: absolute; top: 3px; right: 3px; width: 20px; height: 20px;
        background-color: rgba(220, 53, 69, 0.8); color: white; border: none;
        border-radius: 50%; font-size: 12px; line-height: 20px; text-align: center;
        cursor: pointer; opacity: 0; transition: opacity 0.2s ease-in-out; z-index: 1;
    }
     .dark-mode #imageGallery .delete-img-btn { background-color: rgba(167, 29, 42, 0.8); }
    #imageGallery .img-container:hover .delete-img-btn { opacity: 1; }

     /* Image Reorder Buttons */
    .image-reorder-buttons {
        position: absolute;
        bottom: 3px;
        left: 3px;
        display: flex;
        flex-direction: column;
        gap: 2px;
        z-index: 1;
    }
     .image-reorder-buttons button {
         padding: 2px 5px;
         font-size: 10px;
         cursor: pointer;
         background-color: rgba(108, 117, 125, 0.8); /* Semi-transparent grey */
         color: white;
         border: none;
         border-radius: 3px;
         transition: 0.3s;
     }
      .dark-mode .image-reorder-buttons button { background-color: rgba(85, 85, 85, 0.8); }
     .image-reorder-buttons button:hover {
         background-color: #5a6268;
     }
      .dark-mode .image-reorder-buttons button:hover { background-color: #777; }


    /* Image Modal (Lightbox) Styles */
    .modal {
        display: none; position: fixed; z-index: 1500; padding-top: 50px;
        left: 0; top: 0; width: 100%; height: 100%; overflow: auto;
        background-color: rgba(0,0,0,0.85);
    }
    .modal-content { margin: auto; display: block; max-width: 85%; max-height: 85%; }
    .close-modal {
        position: absolute; top: 15px; right: 35px; color: #f1f1f1;
        font-size: 40px; font-weight: bold; transition: 0.3s; cursor: pointer;
    }
    .close-modal:hover, .close-modal:focus { color: #bbb; text-decoration: none; }
    .modal-nav {
        position: absolute; top: 50%; width: auto; padding: 16px; margin-top: -50px;
        color: white; font-weight: bold; font-size: 30px; transition: 0.3s ease;
        border-radius: 3px; user-select: none; -webkit-user-select: none; cursor: pointer;
        background-color: rgba(0, 0, 0, 0.4);
    }
    .modal-nav:hover { background-color: rgba(0, 0, 0, 0.7); }
    .prev-modal { left: 10px; border-radius: 3px 0 0 3px; }
    .next-modal { right: 10px; border-radius: 0 3px 3px 0; }

    /* Recording Status */
    #recordingStatus { color: red; font-weight: bold; margin-right: 10px; vertical-align: middle; }
    .dark-mode #recordingStatus { color: #ff4d4d; }

     /* General helper for better alignment */
     .center-text { text-align: center; }
     .button-container { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }

    /* Floating Button for Notes */
    #floatingNoteButton {
      position: fixed;
      bottom: 80px;
      right: 25px;
      display: none;
      padding: 15px;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 50%;
      background-color: #007bff;
      color: white;
      transition: 0.3s;
      box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
      font-family: 'Arial', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      vertical-align: middle;
      z-index: 1000;
    }
    #floatingNoteButton:hover {
      background-color: #0056b3;
    }

    /* Reset Button Style (non-floating) */
    #resetPageBtn {
        display: block;
        width: auto;
        margin: 30px auto 20px auto;
        padding: 12px 25px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        border-radius: 5px;
        background-color: #ff4d4d;
        color: white;
        transition: 0.3s;
        box-shadow: 0px 2px 5px rgba(0,0,0,0.2);
        font-family: 'Arial', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #resetPageBtn:hover {
        background-color: #cc0000;
    }


  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

  <h2 class="center-text" style="margin-bottom: 15px; color: #007bff;">ğŸ“º Ù…Ø´ØºÙ„ ÙÙŠØ¯ÙŠÙˆ Ù…ØªÙƒØ§Ù…Ù„ + Ù…Ù„Ø®Øµ Ø°ÙƒÙŠ + Ù…Ù„Ø§Ø­Ø¸Ø§Øª ÙˆØµÙˆØ±</h2>
   <p class="center-text" style="margin-top: -10px; margin-bottom: 20px; font-size: 14px; color: #6c757d;">
        âš ï¸ Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØª: ÙŠØ¬Ø¨ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† Ø¹Ù†Ø¯ Ø§Ù„Ø·Ù„Ø¨ØŒ ÙˆÙŠØ¬Ø¨ ØªØ´ØºÙŠÙ„ Ø§Ù„ØµÙØ­Ø© Ø¹Ø¨Ø± HTTPS Ø£Ùˆ localhost.
   </p>

  <div class="center-text" style="margin-bottom: 25px;">
    <input type="text" id="videoUrl" placeholder="Ø£Ø¯Ø®Ù„ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ ÙŠÙˆØªÙŠÙˆØ¨" style="width: 65%; padding: 12px; max-width: 500px;">
    <button class="control-btn" onclick="loadVideo()">ğŸ¬ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ</button>
  </div>

  <div id="videoContainer"><p class="center-text" style="padding: 20px; color: #6c757d;">Ø£Ø¯Ø®Ù„ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ ÙŠÙˆØªÙŠÙˆØ¨ ÙˆØ§Ø¶ØºØ· "ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ" Ù„Ù„Ø¨Ø¯Ø¡.</p></div>

  <div class="speed-controls">
    <button class="control-btn speed-btn" onclick="changeSpeed(0.5)">0.5x</button>
    <button class="control-btn speed-btn" onclick="changeSpeed(0.75)">0.75x</button>
    <button class="control-btn speed-btn" onclick="changeSpeed(1)">1x</button>
    <button class="control-btn speed-btn" onclick="changeSpeed(1.25)">1.25x</button>
    <button class="control-btn speed-btn" onclick="changeSpeed(1.5)">1.5x</button>
    <button class="control-btn speed-btn" onclick="changeSpeed(2)">2x</button>
  </div>

  <div class="floating-controls">
    <button class="control-btn" onclick="seek(-10)">âª 10Ø«</button>
    <button class="control-btn" onclick="seek(10)">10Ø« â©</button>
  </div>

  <div class="floating-right-controls">
    <button class="control-btn" id="playPauseBtn" onclick="togglePlayPause()">â–¶ ØªØ´ØºÙŠÙ„</button>
  </div>

  <div class="notes-section">
    <h3 style="margin-top: 0; color: #17a2b8;">ğŸ“ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª</h3>
    <textarea id="noteText" placeholder="Ø§ÙƒØªØ¨ Ù…Ù„Ø§Ø­Ø¸Ø© Ù‡Ù†Ø§..." rows="4"></textarea> <div style="margin-top: 10px;"> <button class="control-btn" onclick="saveNote()">ğŸ’¾ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø© Ø§Ù„Ù†ØµÙŠØ©</button>
        <button id="recordNoteBtn" class="record-btn" onclick="toggleRecording()">ğŸ¤ ØªØ³Ø¬ÙŠÙ„ Ø±ÙŠÙƒÙˆØ±Ø¯</button>
        <span id="recordingStatus" style="display:none;">ğŸ”´ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„...</span>
    </div>
  </div>

  <ul id="notesList"></ul>

  <div class="lecture-images-section">
      <h3 style="margin-top: 0; color: #6f42c1;">ğŸ–¼ï¸ ØµÙˆØ± Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø©</h3>
      <label for="imageUpload" class="control-btn" style="display: inline-block; margin-bottom: 15px;">â• Ø¥Ø¶Ø§ÙØ© ØµÙˆØ±</label>
      <input type="file" id="imageUpload" accept="image/*" multiple style="display: none;">
      <div id="imageGallery">
          </div>
  </div>

  <div id="imageModal" class="modal">
        <span class="close-modal" onclick="closeModal()">Ã—</span>
        <img class="modal-content" id="modalImage">
        <a class="modal-nav prev-modal" onclick="changeModalImage(-1)">â®</a>
        <a class="modal-nav next-modal" onclick="changeModalImage(1)">â¯</a>
    </div>

  <div class="search-box">
    <h3 style="margin-top: 0; color: #d63384;">ğŸ” Ø¨Ø­Ø« ÙÙŠ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ</h3>
    <input type="text" id="searchText" placeholder="Ø§Ø¨Ø­Ø« ÙÙŠ Ù†Øµ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...">
    <button class="control-btn" onclick="searchInText()">Ø¨Ø­Ø«</button>
    <button class="clear-search-btn" onclick="clearSearch()" id="clearSearchBtn" style="display:none;">âœ– Ù…Ø³Ø­ Ø§Ù„Ø¨Ø­Ø«</button>
    <div id="searchResults" style="margin-top: 15px; text-align: right;"></div>
  </div>

  <div style="margin-top: 25px;" class="notes-section"> <h3 style="margin-bottom: 15px; color: #6f42c1;">ğŸ“Œ Ø§Ù„Ù†Øµ Ø§Ù„ÙƒØ§Ù…Ù„ (Ø£Ùˆ Ø§Ù„ØµÙ‚Ù‡ Ù‡Ù†Ø§):</h3>
    <textarea id="transcriptInput" placeholder="Ø§Ù†ØªØ¸Ø± Ø¬Ù„Ø¨ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø£Ùˆ Ø§Ù„ØµÙ‚ Ø§Ù„Ù†Øµ Ø§Ù„ÙƒØ§Ù…Ù„ Ù‡Ù†Ø§..." style="height: 180px;"></textarea>
    <div style="margin-top:10px; text-align: center;">
        <button class="control-btn" onclick="summarizeText()">ğŸ“ ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ø®Øµ Ù„Ù„Ù†Øµ Ø£Ø¹Ù„Ø§Ù‡</button>
    </div>
  </div>

  <div id="summaryBox" class="notes-section" style="margin-top: 25px; min-height: 150px;">
      <h3 style="margin-top: 0; color: #007bff;">ğŸ’¡ Ø§Ù„Ù…Ù„Ø®Øµ Ø§Ù„Ø°ÙƒÙŠ</h3>
      <div id="summaryContent">ğŸ” Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ø®Øµ Ø¨Ø¹Ø¯.</div> </div>

  <div class="center-text button-container" style="margin-top: 30px; padding-bottom: 20px;">
      <button class="control-btn" onclick="toggleDarkMode()" style="padding: 12px 25px;">ğŸŒ™ ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹</button>
      <button id="downloadPageBtn" class="control-btn" onclick="downloadPage()" style="padding: 12px 25px; background-color: #28a745;" title="Ø­ÙØ¸ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„ØµÙØ­Ø© Ø¨Ù…Ø§ ÙÙŠÙ‡ Ù…Ù† Ù…Ù„Ø§Ø­Ø¸Ø§Øª ÙˆØµÙˆØ± ÙƒÙ…Ù„Ù HTML ÙˆØ§Ø­Ø¯">ğŸ“¥ Ø­ÙØ¸ Ø§Ù„ØµÙØ­Ø© ÙƒÙ€ HTML</button>
      <button id="exportBtn" class="control-btn" onclick="exportData()" style="padding: 12px 25px; background-color: #ff9800;">ğŸ“¤ ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
      <button id="importBtn" class="control-btn" onclick="importData()" style="padding: 12px 25px; background-color: #9c27b0;">ğŸ“¥ Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
      <button id="toggleFloatingNoteBtn" class="control-btn" onclick="toggleFloatingNoteButton()" style="padding: 12px 25px; background-color: #e91e63;">ğŸ”„ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø²Ø± Ø§Ù„Ø¹Ø§Ø¦Ù…</button>
  </div>

  <button id="resetPageBtn" onclick="resetPage()">ğŸ§¹ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØµÙØ­Ø©</button>

  <button id="floatingNoteButton" onclick="toggleNotesSection()">ğŸ“</button>

  <script>
    const OPENROUTER_API_KEY = "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"; // !!! Ø§Ø³ØªØ¨Ø¯Ù„ Ø¨Ù…ÙØªØ§Ø­Ùƒ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø¨Ø´ÙƒÙ„ Ø¢Ù…Ù†
    let player;
    let notes = [];
    let captionsData = [];
    let isPlaying = false;
    let currentHighlights = [];
    let lectureImages = [];
    let currentModalIndex = -1;
    let currentVideoUrl = '';
    let savedVideoTime = 0; // Added to store saved video time

    // Audio Recording Variables
    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;
    let audioStream = null;

    // --- YouTube API Handling ---
    function loadYouTubeAPI() {
      // Correct YouTube IFrame Player API URL
      if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
        console.log("Loading YouTube API...");
        const tag = document.createElement('script');
        // Using a direct googleapis URL for broader compatibility
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
      } else {
        console.log("YouTube API already loaded.");
        // If API is already loaded and ready, call onYouTubeIframeAPIReady manually
        if (typeof YT.Player === 'function' && typeof YT.PlayerState !== 'undefined') { // Check for YT.PlayerState too
           onYouTubeIframeAPIReady();
        }
      }
    }
     // This function is called automatically by the YouTube IFrame Player API after the API code downloads.
    function onYouTubeIframeAPIReady() {
      console.log("YouTube IFrame API Ready.");
      // If a video URL was loaded from storage, try to load the video
      if (currentVideoUrl) {
          document.getElementById("videoUrl").value = currentVideoUrl;
          // Add a small delay to ensure the DOM is fully ready for the player div
          setTimeout(() => loadVideo(currentVideoUrl), 100);
      }
    }

    function loadVideo(url) {
      const videoUrlInput = document.getElementById("videoUrl");
      const urlToLoad = url || videoUrlInput.value; // Use provided URL or input value
      if (!urlToLoad) return alert("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ ÙŠÙˆØªÙŠÙˆØ¨ ØµØ­ÙŠØ­.");
      const videoId = extractVideoID(urlToLoad);
      if (!videoId) return alert("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· ÙŠÙˆØªÙŠÙˆØ¨ ØµØ­ÙŠØ­.");

      currentVideoUrl = urlToLoad; // Save the loaded URL
      // No need to save state here, it's saved in onPlayerReady after player loads

      if (player && typeof player.destroy === 'function') {
          try { player.destroy(); player = null; console.log("Previous player destroyed.");}
          catch (e) { console.error("Error destroying previous player:", e); }
      }
      // Ensure the player container div exists before creating a new player
       const videoContainer = document.getElementById("videoContainer");
       if (!videoContainer) {
           console.error("Video container element not found!");
           alert("âŒ Ø®Ø·Ø£ Ø¯Ø§Ø®Ù„ÙŠ: Ø¹Ù†ØµØ± Ù…Ø´ØºÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…ÙÙ‚ÙˆØ¯.");
           return;
       }
       videoContainer.innerHTML = '<div id="youtubePlayer"></div><p id="playerStatus" style="text-align:center; padding: 10px; color: #6c757d;">â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...</p>';

      resetAppState(false); // Clear state but keep notes/images for now, pass false to avoid clearing video URL immediately

      if (typeof YT !== 'undefined' && YT.Player) { createPlayer(videoId); }
      else {
          console.warn("YT API not ready when loadVideo called. Waiting...");
          document.getElementById("playerStatus").innerText = "â³ ÙˆØ§Ø¬Ù‡Ø© ÙŠÙˆØªÙŠÙˆØ¨ Ù‚ÙŠØ¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...";
           setTimeout(() => {
              if (!player && typeof YT !== 'undefined' && YT.Player) { createPlayer(videoId); }
              else if (!player) {
                   console.error("YT API did not become ready.");
                    const statusEl = document.getElementById("playerStatus");
                    if (statusEl) statusEl.innerText = "âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ ÙˆØ§Ø¬Ù‡Ø© ÙŠÙˆØªÙŠÙˆØ¨. Ø­Ø§ÙˆÙ„ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.";
                    alert("âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ ÙˆØ§Ø¬Ù‡Ø© ÙŠÙˆØªÙŠÙˆØ¨. Ø­Ø§ÙˆÙ„ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©.");
              }
           }, 4000); // Wait 4 seconds
      }
      // fetchTranscript(videoId); // Temporarily commented out to use pasted transcript
    }
    function createPlayer(videoId) {
        try {
            player = new YT.Player('youtubePlayer', {
                height: '450', width: '100%', videoId: videoId,
                playerVars: { 'playsinline': 1 },
                events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateStateChange, 'onError': onPlayerError }
            });
            console.log("YT.Player instance requested.");
        } catch (e) {
            console.error("Error creating YT.Player instance:", e);
            const statusEl = document.getElementById("playerStatus");
            if (statusEl) statusEl.innerText = "âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´ØºÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ.";
            alert("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ‡ÙŠØ¦Ø© Ù…Ø´ØºÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ.");
        }
    }
    function onPlayerReady(event) {
        player = event.target;
        console.log("Player ready (onReady event).");
        const statusEl = document.getElementById("playerStatus");
        if (statusEl) statusEl.remove(); // Remove loading message
        isPlaying = (player.getPlayerState() === YT.PlayerState.PLAYING);
        updatePlayPauseButton();

        // Seek to saved time if it exists
        if (savedVideoTime > 0) {
            try {
                player.seekTo(savedVideoTime, true);
                console.log(`Seeking to saved time: ${formatTime(savedVideoTime)}`);
                savedVideoTime = 0; // Reset after seeking
            } catch (e) {
                console.error("Error seeking to saved time:", e);
            }
        }

        // Start saving state periodically
        startPeriodicSave();
    }
    function onPlayerError(event) {
        console.error("YouTube Player Error Code:", event.data);
        let errorMsg = `âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø´ØºÙ„ ÙŠÙˆØªÙŠÙˆØ¨ (Ø±Ù…Ø² Ø§Ù„Ø®Ø·Ø£: ${event.data}).`;
        switch(event.data) {
            case 2: errorMsg += " Ø·Ù„Ø¨ ØºÙŠØ± ØµØ§Ù„Ø­."; break;
            case 5: errorMsg += " Ø®Ø·Ø£ ÙÙŠ Ù…Ø´ØºÙ„ HTML5."; break;
            case 100: case 101: case 150: errorMsg += " Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ Ø®Ø§Øµ Ø£Ùˆ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¶Ù…ÙŠÙ†Ù‡."; break;
            default: errorMsg += " Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ.";
        }
        document.getElementById("videoContainer").innerHTML = `<p style="color: red; text-align: center; padding: 20px;">${errorMsg}</p>`;
        player = null; isPlaying = false; updatePlayPauseButton();
        currentVideoUrl = ''; // Clear video URL on error
        savedVideoTime = 0; // Clear saved time on error
        saveStateToLocalStorage();
        stopPeriodicSave(); // Stop saving on error
    }
    function extractVideoID(url) {
        const regex = /(?:youtube(?:-nocookie)?\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|watch(?:\?v=|\/))|youtu\.be\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/;
        return (url.match(regex) || [])[1] || null;
    }
    function onPlayerStateStateChange(event) {
        isPlaying = (event.data == YT.PlayerState.PLAYING);
        updatePlayPauseButton();
         // Save state when player state changes (e.g., paused, ended)
        if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
            saveStateToLocalStorage();
        }
    }
    function togglePlayPause() {
        if (!player || typeof player.getPlayerState !== 'function') return alert("âŒ Ø§Ù„Ù…Ø´ØºÙ„ ØºÙŠØ± Ø¬Ø§Ù‡Ø².");
        try {
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PLAYING) player.pauseVideo();
            else player.playVideo();
        } catch (e) { console.error("Error toggling play/pause:", e); alert("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ´ØºÙŠÙ„/Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù."); }
    }
    function updatePlayPauseButton() {
        const btn = document.getElementById("playPauseBtn");
        if (btn) btn.innerHTML = isPlaying ? "â¸ Ø¥ÙŠÙ‚Ø§Ù" : "â–¶ ØªØ´ØºÙŠÙ„";
    }
    function changeSpeed(speed) {
        if (!player || typeof player.setPlaybackRate !== 'function') return alert("âŒ Ø§Ù„Ù…Ø´ØºÙ„ ØºÙŠØ± Ø¬Ø§Ù‡Ø².");
        try { player.setPlaybackRate(speed); console.log("Playback rate set to:", speed); }
        catch (e) { console.error("Error setting playback rate:", e); alert("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØºÙŠÙŠØ± Ø§Ù„Ø³Ø±Ø¹Ø©."); }
    }
    function seek(seconds) {
        if (!player || typeof player.seekTo !== 'function') return alert("âŒ Ø§Ù„Ù…Ø´ØºÙ„ ØºÙŠØ± Ø¬Ø§Ù‡Ø².");
        try {
            let currentTime = player.getCurrentTime() || 0;
            let newTime = Math.max(0, currentTime + seconds);
            const duration = player.getDuration();
            if (duration && newTime > duration) newTime = duration;
            player.seekTo(newTime, true);
        } catch (e) { console.error("Error seeking:", e); alert("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„."); }
    }

    // --- Transcript & Search ---
    async function fetchTranscript(videoId) {
        document.getElementById("transcriptInput").value = "âš ï¸ ÙŠØ±Ø¬Ù‰ Ù„ØµÙ‚ Ù†Øµ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ù‡Ù†Ø§.";
        captionsData = []; // Clear any old caption data
         // Simulate fetching transcript - user will paste manually for now
    }

    // Updated parseTranscriptWithTimestamps to handle HH:MM:SS,ms --> HH:MM:SS,ms format
    function parseTranscriptWithTimestamps(transcript) {
        const lines = transcript.split('\n');
        const data = [];
        // Regex for "HH:MM:SS,ms --> HH:MM:SS,ms Text" format
        const srtTimeRegex = /(\d{1,2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*\d{1,2}:\d{2}:\d{2},\d{3}(.*)/;
        // Regex for "MM:SS Text" or "M:SS Text" format (kept from previous version)
        const simpleTimeRegex = /^(\d{1,2}):(\d{2}(\.\d+)?)\s*(.*)/; // Added capturing group for text

        lines.forEach(line => {
            const srtMatch = line.match(srtTimeRegex);
            const simpleMatch = line.match(simpleTimeRegex);

            if (srtMatch) {
                // Extract start time from SRT format
                const hours = parseInt(srtMatch[1], 10);
                const minutes = parseInt(srtMatch[2], 10);
                const seconds = parseInt(srtMatch[3], 10);
                const milliseconds = parseInt(srtMatch[4], 10);
                const timeInSeconds = (hours * 3600) + (minutes * 60) + seconds + (milliseconds / 1000);
                // Get the text from the last capturing group
                const text = srtMatch[5].trim();
                if (text) data.push({ time: timeInSeconds, text: text });

            } else if (simpleMatch) {
                // Extract start time from simple format
                const minutes = parseInt(simpleMatch[1], 10);
                const seconds = parseFloat(simpleMatch[2]);
                const timeInSeconds = (minutes * 60) + seconds;
                 // Get the text from the last capturing group
                const text = simpleMatch[4].trim();
                if (text) data.push({ time: timeInSeconds, text: text });

            } else if (line.trim() !== '' && data.length > 0) {
                // If a line doesn't match a timestamp format, append it to the text of the *last* segment
                // This handles multi-line text within a single time segment
                data[data.length - 1].text += '\n' + line.trim(); // Use newline to preserve line breaks
            }
             // Ignore empty lines or lines that don't fit the pattern unless appending to previous segment
        });

        return data;
    }


    function searchInText() {
        const query = document.getElementById("searchText").value.trim();
        if (!query) return alert("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù†Øµ Ù„Ù„Ø¨Ø­Ø«");
        const transcriptArea = document.getElementById("transcriptInput");
        const transcript = transcriptArea.value;
        if (!transcript || transcript.includes("â³") || transcript.includes("âš ï¸")) {
            return alert("âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Øµ ØµØ§Ù„Ø­ Ù„Ù„Ø¨Ø­Ø« ÙÙŠÙ‡");
        }
        clearSearchHighlights(); // Clear previous highlights

        // Re-parse the transcript based on the current text in the textarea
        const currentTranscriptData = parseTranscriptWithTimestamps(transcript);
        let resultsHTML = '';
        let foundCount = 0;
        currentHighlights = [];
        const queryLower = query.toLowerCase();

        currentTranscriptData.forEach((item, index) => {
            if (item.text.toLowerCase().includes(queryLower)) {
                foundCount++;
                const highlightedTextHTML = highlightText(item.text, query); // Highlight text within the segment
                let jumpTime = item.time;

                // Display the segment time and highlighted text
                resultsHTML += `<div class="highlight-line" onclick="jumpTo(${jumpTime})">
                    <b>[${formatTime(jumpTime)}]</b> ${highlightedTextHTML}
                    <button class="control-btn" style="padding: 2px 6px !important; font-size: 12px !important; margin-left: 5px;">ğŸ”—</button>
                  </div>`;
                // We store the index of the transcript segment, not line number from textarea
                currentHighlights.push(index);
            }
        });


        const searchResultsDiv = document.getElementById("searchResults");
        if (foundCount > 0) {
            searchResultsDiv.innerHTML = `<p>ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${foundCount} Ù†ØªØ§Ø¦Ø¬:</p>${resultsHTML}`;
            document.getElementById("clearSearchBtn").style.display = 'inline-block';

            // Add click listener to the jump buttons within search results dynamically
             searchResultsDiv.querySelectorAll('.highlight-line button').forEach(button => {
                 button.addEventListener('click', function(event) {
                      event.stopPropagation(); // Prevent the parent div's click
                      // Extract jump time from the parent div's onclick attribute
                      const jumpTime = parseFloat(this.closest('.highlight-line').getAttribute('onclick').match(/jumpTo\(([^)]+)\)/)[1]);
                      if (!isNaN(jumpTime)) jumpTo(jumpTime);
                 });
             });

        } else {
            searchResultsDiv.innerHTML = "âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬";
            document.getElementById("clearSearchBtn").style.display = 'none';
        }
    }


    function clearSearch() {
        clearSearchHighlights();
        document.getElementById("searchResults").innerHTML = '';
        document.getElementById("searchText").value = '';
        document.getElementById("clearSearchBtn").style.display = 'none';
        const textarea = document.getElementById("transcriptInput");
        try { textarea.setSelectionRange(0,0); textarea.scrollTop = 0; } catch(e){}
    }
    function clearSearchHighlights() {
         const searchResultsDiv = document.getElementById("searchResults");
         if (searchResultsDiv) {
             searchResultsDiv.innerHTML = ''; // Clear results div content
         }
        currentHighlights = [];
    }
    function highlightText(text, query) {
        if (!query) return text;
        try {
            const regex = new RegExp(`(${escapeRegExp(query)})`, 'gi');
             return text.replace(regex, '<span class="highlight">$1</span>');
        } catch (e) { return text; }
    }
    function escapeRegExp(string) {
         return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // --- Summarization ---
    async function summarizeText() {
         const text = document.getElementById("transcriptInput").value;
          if (!text || text.includes("â³") || text.includes("âš ï¸")) {
              return alert("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù†Øµ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø£Ùˆ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø­ØªÙ‰ ÙŠØªÙ… Ø¬Ù„Ø¨Ù‡.");
          }
          const summaryContainer = document.getElementById("summaryContent");
          summaryContainer.innerHTML = "â³ Ø¬Ø§Ø±ÙŠ ØªÙ„Ø®ÙŠØµ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… DeepSeek...";
          try {
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${OPENROUTER_API_KEY}`, "Content-Type": "application/json",
                "HTTP-Referer": window.location.href, "X-Title": "Video Summarizer Tool",
              },
              body: JSON.stringify({
                "model": "deepseek/deepseek-coder",
                "messages": [{
                  "role": "system", "content": `Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªØ®ØµØµ ÙÙŠ ØªÙ„Ø®ÙŠØµ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØŒ Ø®Ø§ØµØ© Ø§Ù„Ù…Ø­Ø§Ø¶Ø±Ø§Øª Ø§Ù„ØªÙ‚Ù†ÙŠØ©. Ù„Ø®Øµ Ø§Ù„Ù†Øµ Ø¨Ø¯Ù‚Ø© Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ† ÙˆØ§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨ØµÙŠØºØ© LaTeX ÙƒÙ…Ø§ Ù‡ÙŠ ØªÙ…Ø§Ù…Ø§Ù‹. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† ÙˆØ§Ù„Ù‚ÙˆØ§Ø¦Ù… Ù„ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¨Ù„ÙŠØ© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©.`
                }, {
                  "role": "user", "content": `Ù„Ø®Øµ Ø§Ù„Ù†Øµ Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø¹ Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙˆØ§Ù„Ù‚ÙˆØ§Ù†ÙŠÙ† ÙˆØ§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… LaTeX:\n\n${text}`
                }]
              })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`ÙØ´Ù„ Ø·Ù„Ø¨ Ø§Ù„ØªÙ„Ø®ÙŠØµ: ${response.status} ${response.statusText}. ${errorData.error?.message || ''}`);
            }
            const data = await response.json();
            if (!data.choices?.[0]?.message?.content) { throw new Error("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ø®Øµ ÙÙŠ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ù€ API."); }
            let summary = data.choices[0].message.content;
            summary = processSummaryContent(summary);
            summaryContainer.innerHTML = summary;
            renderMathInElement(summaryContainer);
            saveStateToLocalStorage();
          } catch (error) {
            summaryContainer.innerHTML = `âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù„Ø®Øµ: ${error.message}`;
            console.error(error);
          }
    }
    function processSummaryContent(summary) {
        summary = summary
          .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>')
          .replace(/\*(.*?)\*/g, '<i>$1</i>')
          .replace(/`(.*?)`/g, '<code>$1</code>');

        summary = summary.replace(/^### (.*$)/gim, '<h4>$1</h4>')
                         .replace(/^## (.*$)/gim, '<h3>$1</h3>')
                         .replace(/^# (.*$)/gim, '<h2>$1</h2>');

        summary = summary.replace(/^\s*-\s+(.*)/gm, '<li>$1</li>')
                         .replace(/^\s*\d+\.\s+(.*)/gm, '<li>$1</li>');

        summary = summary.replace(/((<li>.*?<\/li>\s*)+)/gs, (match) => {
             const isOrdered = /^\s*\d+\./m.test(match);
             return isOrdered ? `<ol>${match}</ol>` : `<ul>${match}</ul>`;
        });

        summary = summary.split('\n').map(line => {
            if (line.trim().startsWith('<li') || line.trim().startsWith('<h') || line.trim() === '' || line.includes('<code>') || line.includes('</code>')) {
                return line;
            }
             if (line.trim().startsWith('<div class="math-container">') || line.trim().startsWith('<span class="latex">')) {
                 return line;
             }

            return line + '<br>';
        }).join('');


        summary = formatMathEquations(summary);

         summary = summary.replace(/<br>\s*<(ul|ol|div class="math-container")>/g, '<$1>').replace(/<\/(ul|ol|div class="math-container")>\s*<br>/g, '</$1>');


        return summary;
    }

    function formatMathEquations(text) {
        text = text.replace(/\\\[([\s\S]*?)\\\]/g, (m, eq) => `<div class="math-container">\\[${eq.trim()}\\]</div>`);
        text = text.replace(/\\\((.*?)\\\)/g, (m, eq) => eq.trim() ? `<span class="latex">\\(${eq.trim()}\\)</span>` : '');
        return text;
    }
    function renderMathInElement(element) {
         if (element && (element.innerHTML.includes('\\(') || element.innerHTML.includes('\\['))) {
             if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                MathJax.typesetPromise([element]).catch((err) => console.error('MathJax error:', err));
            } else {
                if (typeof MathJax !== 'undefined' && MathJax.typeset) {
                    MathJax.typeset([element]);
                }
            }
         }
    }


    // --- Notes Management (Up/Down Buttons) ---
    function saveNote() {
        const noteTextElement = document.getElementById("noteText");
        const noteText = noteTextElement.value.trim();
        if (!noteText) return alert("âŒ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ù…Ù„Ø§Ø­Ø¸Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸.");
        if (!player || typeof player.getCurrentTime !== 'function') {
             console.warn("Player not ready, saving note with current time estimate.");
             notes.push({ time: Date.now() / 1000, type: 'text', text: noteText });
        } else {
            try {
                const currentTime = player.getCurrentTime();
                notes.push({ time: currentTime, type: 'text', text: noteText });
            } catch (e) {
                 console.error("Error getting player time for note:", e);
                 notes.push({ time: Date.now() / 1000, type: 'text', text: noteText });
            }
        }

        updateNotesList();
        noteTextElement.value = "";
        saveStateToLocalStorage();
    }

     async function toggleRecording() {
        const recordBtn = document.getElementById('recordNoteBtn');
        const statusIndicator = document.getElementById('recordingStatus');
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            return alert('âŒ Ù…ØªØµÙØ­Ùƒ Ù„Ø§ ÙŠØ¯Ø¹Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØª.');
        }
        if (!window.isSecureContext) {
             return alert('âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØµÙˆØª Ø¥Ù„Ø§ Ù…Ù† ØµÙØ­Ø© Ø¢Ù…Ù†Ø© (HTTPS) Ø£Ùˆ localhost.');
        }

        if (isRecording) {
            // Stop
            try {
                if (mediaRecorder?.state === "recording") mediaRecorder.stop();
                if(audioStream) audioStream.getTracks().forEach(track => track.stop()); audioStream = null;
            } catch (e) { console.error("Error stopping recording:", e); }
            finally {
                 recordBtn.classList.remove('recording'); recordBtn.innerHTML = 'ğŸ¤ ØªØ³Ø¬ÙŠÙ„'; statusIndicator.style.display = 'none'; isRecording = false;
            }
        } else {
            // Start
            if (!player || typeof player.getCurrentTime !== 'function' || typeof player.getPlayerState !== 'function' || player.getPlayerState() === YT.PlayerState.UNSTARTED) {
                 console.warn("Player not ready, recording note with current time estimate.");
            }
            let recordingStartTime = 0;
            try {
                if(player && typeof player.getCurrentTime === 'function') recordingStartTime = player.getCurrentTime();
            }
            catch(e) { console.error("Failed to get player time for recording:", e); }


            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(audioStream); audioChunks = [];
                mediaRecorder.ondataavailable = e => { if (e.data.size > 0) audioChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    if (audioChunks.length === 0) {
                        alert("âš ï¸ Ù„Ù… ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª ØµÙˆØªÙŠØ©.");
                         if(audioStream) audioStream.getTracks().forEach(track => track.stop()); audioStream = null;
                         return;
                    }
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        notes.push({ time: recordingStartTime, type: 'audio', data: reader.result });
                        updateNotesList(); saveStateToLocalStorage(); audioChunks = [];
                    };
                    reader.onerror = (error) => { console.error("FileReader error:", error); alert("âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØª."); audioChunks = []; };
                    reader.readAsDataURL(audioBlob);
                     if(audioStream) audioStream.getTracks().forEach(track => track.stop()); audioStream = null;
                };
                 mediaRecorder.onerror = (event) => {
                     console.error("MediaRecorder Error:", event.error); alert(`âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø³Ø¬Ù„ Ø§Ù„ØµÙˆØª: ${event.error.name}`);
                     if(audioStream) audioStream.getTracks().forEach(track => track.stop()); audioStream = null;
                     recordBtn.classList.remove('recording'); recordBtn.innerHTML = 'ğŸ¤ ØªØ³Ø¬ÙŠÙ„'; statusIndicator.style.display = 'none'; isRecording = false;
                 };
                mediaRecorder.start();
                recordBtn.classList.add('recording'); recordBtn.innerHTML = 'â¹ Ø¥ÙŠÙ‚Ø§Ù'; statusIndicator.style.display = 'inline'; isRecording = true;
            } catch (err) {
                console.error('Error starting recording:', err); isRecording = false;
                recordBtn.classList.remove('recording'); recordBtn.innerHTML = 'ğŸ¤ ØªØ³Ø¬ÙŠÙ„'; statusIndicator.style.display = 'none';
                if(audioStream) audioStream.getTracks().forEach(track => track.stop()); audioStream = null;
                handleRecordingError(err);
            }
        }
    }

    function handleRecordingError(err) {
        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') alert('âŒ ØªÙ… Ø±ÙØ¶ Ø¥Ø°Ù† Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ù‡ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªØµÙØ­.');
        else if (err.name === 'NotFoundError') alert('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ†.');
        else if (err.name === 'NotReadableError') alert('âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙÙˆÙ† (Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù…Ø³ØªØ®Ø¯Ù…Ø§Ù‹).');
        else if (err.name === 'SecurityError') alert('âŒ Ø®Ø·Ø£ Ø£Ù…Ù†ÙŠ (ØªØ­Ù‚Ù‚ Ù…Ù† HTTPS/localhost).');
        else alert(`âŒ Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ ÙÙŠ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„: ${err.name}`);
    }


    function updateNotesList() {
        const notesListElement = document.getElementById("notesList");
        notesListElement.innerHTML = "";

        notes.forEach((note, index) => {
            let listItem = document.createElement("li");
            listItem.setAttribute('data-note-index', index);

            // Add reorder buttons (up/down)
            const reorderButtons = document.createElement('div');
            reorderButtons.className = 'reorder-buttons';

            const upButton = document.createElement('button');
            upButton.innerHTML = 'â–²';
            upButton.title = 'ØªØ­Ø±ÙŠÙƒ Ù„Ø£Ø¹Ù„Ù‰';
            upButton.onclick = () => moveNoteUp(index);
            if (index === 0) upButton.disabled = true;

            const downButton = document.createElement('button');
            downButton.innerHTML = 'â–¼';
            downButton.title = 'ØªØ­Ø±ÙŠÙƒ Ù„Ø£Ø³ÙÙ„';
            downButton.onclick = () => moveNoteDown(index);
            if (index === notes.length - 1) downButton.disabled = true;

            reorderButtons.appendChild(upButton);
            reorderButtons.appendChild(downButton);

            // Create a container for the note content (text/audio)
            const noteContent = document.createElement('div');
            noteContent.className = 'note-content';

            let contentHTML = `<b>[${formatTime(note.time)}]</b> `; // Bold timestamp

            if (note.type === 'text') {
               const textNode = document.createTextNode(note.text);
               noteContent.innerHTML = contentHTML; // Add timestamp HTML
               noteContent.appendChild(textNode); // Append text node directly for natural wrapping
            } else if (note.type === 'audio') {
                 noteContent.innerHTML = contentHTML + `Ù…Ù„Ø§Ø­Ø¸Ø© ØµÙˆØªÙŠØ©: <audio controls src="${note.data}"></audio>`;
            }

            // Create a container for the jump and delete buttons BELOW the content
            const noteButtonsContainer = document.createElement('div');
            noteButtonsContainer.className = 'note-buttons-container'; // Apply class for styling

            const jumpButton = document.createElement('button');
            jumpButton.className = 'control-btn';
            jumpButton.innerHTML = 'ğŸ”—';
            jumpButton.title = 'Ø§Ù†ØªÙ‚Ù„ Ø¥Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„ÙˆÙ‚Øª';
            jumpButton.onclick = () => jumpTo(note.time);

            const deleteButton = document.createElement('button');
            deleteButton.className = 'clear-search-btn';
            deleteButton.innerHTML = 'ğŸ—‘ï¸';
            deleteButton.title = 'Ø­Ø°Ù Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©';
            deleteButton.onclick = () => deleteNote(index);

            noteButtonsContainer.appendChild(jumpButton);
            noteButtonsContainer.appendChild(deleteButton);

            // Append elements to the list item in the desired order
            listItem.appendChild(reorderButtons); // Up/Down buttons first
            listItem.appendChild(noteContent); // Content next
            listItem.appendChild(noteButtonsContainer); // Jump/Delete buttons last


            notesListElement.appendChild(listItem);
        });
        renderMathInElement(notesListElement); // Render MathJax in notes
    }

    // --- Note Reordering Functions (Up/Down Buttons) ---
    function moveNoteUp(index) {
        if (index > 0) {
            [notes[index], notes[index - 1]] = [notes[index - 1], notes[index]]; // Swap notes
            updateNotesList(); // Update display
            saveStateToLocalStorage(); // Save new order
        }
    }

    function moveNoteDown(index) {
        if (index < notes.length - 1) {
            [notes[index], notes[index + 1]] = [notes[index + 1], notes[index]]; // Swap notes
            updateNotesList(); // Update display
            saveStateToLocalStorage(); // Save new order
        }
    }


    function deleteNote(index) {
        if (index < 0 || index >= notes.length) return;
        const noteType = notes[index].type === 'text' ? 'Ø§Ù„Ù†ØµÙŠØ©' : 'Ø§Ù„ØµÙˆØªÙŠØ©';
        const noteTime = formatTime(notes[index].time);
        if (confirm(`Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø© ${noteType} Ø¹Ù†Ø¯ ${noteTime}ØŸ`)) {
            notes.splice(index, 1);
            updateNotesList();
            saveStateToLocalStorage();
        }
    }

    function jumpTo(time) {
        if (!player || typeof player.seekTo !== 'function') return alert("âŒ Ø§Ù„Ù…Ø´ØºÙ„ ØºÙŠØ± Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ù†ØªÙ‚Ø§Ù„.");
        try {
            player.seekTo(time, true);
            if (player.getPlayerState() !== YT.PlayerState.PLAYING) player.playVideo();
        } catch (e) { console.error("Error jumping:", e); alert("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„."); }
    }
    function formatTime(seconds) {
         seconds = Math.max(0, seconds || 0);
         let min = Math.floor(seconds / 60);
         let sec = Math.floor(seconds % 60);
         let hours = Math.floor(min / 60);
         min = min % 60;
         // Return HH:MM:SS if hours > 0, otherwise MM:SS
         if (hours > 0) {
              return `${hours}:${min < 10 ? "0" : ""}${min}:${sec < 10 ? "0" : ""}${sec}`;
         } else {
              return `${min}:${sec < 10 ? "0" : ""}${sec}`;
         }
    }


    // --- Image Gallery & Modal ---
    function setupImageHandling() {
        const imageUploadInput = document.getElementById('imageUpload');
        const imageModal = document.getElementById('imageModal');
        if (imageUploadInput) imageUploadInput.addEventListener('change', handleImageUpload);
        if (imageModal) imageModal.addEventListener('click', function(event) { if (event.target === this) closeModal(); });
    }
    function handleImageUpload(event) {
        const files = event.target.files;
        if (!files || files.length === 0) return;
        const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
        if (imageFiles.length === 0 && files.length > 0) {
             alert("âŒ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„ÙØ§Øª ØµÙˆØ± ÙÙ‚Ø·."); event.target.value = ''; return;
        }
        if (imageFiles.length === 0) return;
        processImageFiles(imageFiles, () => { event.target.value = ''; });
    }
    function processImageFiles(files, callback) {
        const MAX_CONCURRENT_READS = 5; let currentReads = 0; const processQueue = [...files]; let addedCount = 0;
        function processNextFile() {
            if (processQueue.length === 0) { if (currentReads === 0) { if (addedCount > 0) { updateImageGallery(); saveStateToLocalStorage(); } if (callback) callback(); } return; }
            if (currentReads >= MAX_CONCURRENT_READS) return;
            currentReads++; const file = processQueue.shift(); const reader = new FileReader();
            reader.onloadend = () => { if (reader.result && String(reader.result).startsWith('data:image')) { lectureImages.push({ id: Date.now() + '-' + Math.random().toString(16).slice(2), data: reader.result }); addedCount++; } currentReads--; processNextFile(); };
            reader.onerror = (error) => { console.error("FileReader img error:", file.name, error); alert(`âŒ Ø®Ø·Ø£ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„ØµÙˆØ±Ø©: ${file.name}`); currentReads--; processNextFile(); };
            reader.readAsDataURL(file); processNextFile();
        }
        processNextFile();
    }
    function updateImageGallery() {
        const gallery = document.getElementById('imageGallery'); gallery.innerHTML = '';
        lectureImages.forEach((imgData, index) => {
            const container = document.createElement('div'); container.className = 'img-container';
            const imgElement = document.createElement('img'); imgElement.src = imgData.data; imgElement.alt = `ØµÙˆØ±Ø© ${index + 1}`; imgElement.title = `ØµÙˆØ±Ø© ${index + 1}`; imgElement.onclick = () => openModal(index); imgElement.onerror = () => { imgElement.alt = "Ø®Ø·Ø£"; imgElement.style.border = "2px solid red";};
            const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = 'Ã—'; deleteBtn.className = 'delete-img-btn'; deleteBtn.title = 'Ø­Ø°Ù'; deleteBtn.onclick = (e) => { e.stopPropagation(); deleteImage(index); };

             // Add image reorder buttons
            const reorderButtons = document.createElement('div');
            reorderButtons.className = 'image-reorder-buttons';

            const upButton = document.createElement('button');
            upButton.innerHTML = 'â–²';
            upButton.title = 'ØªØ­Ø±ÙŠÙƒ Ù„Ø£Ø¹Ù„Ù‰';
            upButton.onclick = (e) => { e.stopPropagation(); moveImageUp(index); };
            if (index === 0) upButton.disabled = true;

            const downButton = document.createElement('button');
            downButton.innerHTML = 'â–¼';
            downButton.title = 'ØªØ­Ø±ÙŠÙƒ Ù„Ø£Ø³ÙÙ„';
            downButton.onclick = (e) => { e.stopPropagation(); moveImageDown(index); };
            if (index === lectureImages.length - 1) downButton.disabled = true;

            reorderButtons.appendChild(upButton);
            reorderButtons.appendChild(downButton);

            container.appendChild(imgElement);
            container.appendChild(deleteBtn);
            container.appendChild(reorderButtons); // Add reorder buttons to the container
            gallery.appendChild(container);
        });
    }

     // --- Image Reordering Functions ---
     function moveImageUp(index) {
        if (index > 0) {
            [lectureImages[index], lectureImages[index - 1]] = [lectureImages[index - 1], lectureImages[index]]; // Swap images
            updateImageGallery(); // Update display
            saveStateToLocalStorage(); // Save new order
        }
     }

     function moveImageDown(index) {
        if (index < lectureImages.length - 1) {
            [lectureImages[index], lectureImages[index + 1]] = [lectureImages[index + 1], lectureImages[index]]; // Swap images
            updateImageGallery(); // Update display
            saveStateToLocalStorage(); // Save new order
        }
        }


    function deleteImage(index) {
        if (index < 0 || index >= lectureImages.length) return;
        if (confirm(`Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø©ØŸ`)) { lectureImages.splice(index, 1); updateImageGallery(); saveStateToLocalStorage(); }
    }
    function openModal(index) {
        if (index < 0 || index >= lectureImages.length) return;
        currentModalIndex = index; const modal = document.getElementById('imageModal'); const modalImg = document.getElementById('modalImage');
        modalImg.src = lectureImages[currentModalIndex].data; modal.style.display = 'block';
        document.addEventListener('keydown', handleModalKeydown); document.body.style.overflow = 'hidden';
    }
    function closeModal() {
        const modal = document.getElementById('imageModal'); modal.style.display = 'none';
        document.removeEventListener('keydown', handleModalKeydown); document.body.style.overflow = '';
    }
    function changeModalImage(step) {
        const totalImages = lectureImages.length; if (totalImages === 0) return;
        currentModalIndex = (currentModalIndex + step + totalImages) % totalImages;
        const modalImg = document.getElementById('modalImage');
        if(lectureImages[currentModalIndex]) modalImg.src = lectureImages[currentModalIndex].data; else closeModal();
    }
    function handleModalKeydown(event) {
        if (document.getElementById('imageModal').style.display !== 'block') { document.removeEventListener('keydown', handleModalKeydown); return; }
        switch (event.key) { case 'Escape': closeModal(); break; case 'ArrowLeft': changeModalImage(-1); break; case 'ArrowRight': changeModalImage(1); break; }
    }

    // --- Dark Mode ---
    function toggleDarkMode() {
        document.body.classList.toggle("dark-mode");
        const isDarkMode = document.body.classList.contains("dark-mode");
        localStorage.setItem('darkMode', isDarkMode ? 'enabled' : 'disabled');
        renderMathInElement(document.getElementById('summaryContent'));
        renderMathInElement(document.getElementById('notesList'));
    }

    // --- State Persistence (LocalStorage) ---
    const LOCAL_STORAGE_KEY = 'youtubeVideoSummarizerState_v5'; // Updated key for new version

    function startPeriodicSave() {
        // Save state every 30 seconds if player is available
        if (!window.saveInterval) {
             window.saveInterval = setInterval(() => {
                if (player && typeof player.getCurrentTime === 'function') {
                    saveStateToLocalStorage();
                }
             }, 30000); // Save every 30 seconds
        }
    }

    function stopPeriodicSave() {
        if (window.saveInterval) {
            clearInterval(window.saveInterval);
            window.saveInterval = null;
        }
    }


    function saveStateToLocalStorage() {
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
             try {
                const state = {
                    notes: notes,
                    lectureImages: lectureImages,
                    transcript: document.getElementById('transcriptInput')?.value || '',
                    summary: document.getElementById('summaryContent')?.innerHTML || '',
                    videoUrl: currentVideoUrl,
                    // Save the current video time
                    currentTime: (player && typeof player.getCurrentTime === 'function') ? player.getCurrentTime() : 0
                };
                const stateString = JSON.stringify(state);
                localStorage.setItem(LOCAL_STORAGE_KEY, stateString);
                console.log(`State saved to LocalStorage at time: ${formatTime(state.currentTime)}`);
            } catch (error) {
                 console.error("Error saving state to LocalStorage:", error);
                 if (error.name === 'QuotaExceededError') {
                     console.warn("LocalStorage quota exceeded. Data might not be saved correctly.");
                 }
            }
        }, 500); // Debounce saving
    }

    function loadStateFromLocalStorage() {
         try {
            const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedState) {
                const state = JSON.parse(savedState);
                console.log("Loading state from LocalStorage.");
                notes = state.notes || [];
                lectureImages = state.lectureImages || [];
                document.getElementById('transcriptInput').value = state.transcript || '';
                const summaryContainer = document.getElementById('summaryContent');
                if (summaryContainer) {
                   summaryContainer.innerHTML = state.summary || 'ğŸ” Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ø®Øµ Ø¨Ø¹Ø¯.';
                }
                currentVideoUrl = state.videoUrl || '';
                document.getElementById("videoUrl").value = currentVideoUrl;
                // Load the saved video time
                savedVideoTime = state.currentTime || 0;


                updateNotesList();
                updateImageGallery();
                renderMathInElement(document.getElementById('summaryContent'));
                renderMathInElement(document.getElementById('notesList'));

                // If a video URL was loaded, load the video. Seeking will happen in onPlayerReady.
                if (currentVideoUrl) {
                    // Delay loading the video slightly to ensure the DOM is ready
                     setTimeout(() => loadVideo(currentVideoUrl), 50);
                }


            } else { console.log("No saved state found."); }
         } catch (error) { console.error("Error loading state:", error); }
        const darkModePref = localStorage.getItem('darkMode');
        if (darkModePref === 'enabled' && !document.body.classList.contains('dark-mode')) { document.body.classList.add("dark-mode"); }
        else if (darkModePref === 'disabled' && document.body.classList.contains('dark-mode')) { document.body.classList.remove("dark-mode"); }
    }

    // --- Export/Import Data ---
    function exportData() {
        try {
            const state = {
                notes: notes,
                lectureImages: lectureImages,
                transcript: document.getElementById('transcriptInput').value,
                summary: document.getElementById('summaryContent').innerHTML,
                videoUrl: currentVideoUrl,
                 // Include current video time in export
                currentTime: (player && typeof player.getCurrentTime === 'function') ? player.getCurrentTime() : 0
            };
            const stateString = JSON.stringify(state, null, 2);
            const blob = new Blob([stateString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'lecture_data_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Data exported successfully.");
        } catch (error) {
            console.error("Error exporting data:", error);
            alert("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØµØ¯ÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.");
        }
    }

    function importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.onchange = (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedState = JSON.parse(e.target.result);
                        notes = importedState.notes || [];
                        lectureImages = importedState.lectureImages || [];
                        document.getElementById('transcriptInput').value = importedState.transcript || '';
                        document.getElementById('summaryContent').innerHTML = importedState.summary || 'ğŸ” Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ø®Øµ Ø¨Ø¹Ø¯.';
                        currentVideoUrl = importedState.videoUrl || '';
                        document.getElementById("videoUrl").value = currentVideoUrl;
                         // Load saved video time from import
                        savedVideoTime = importedState.currentTime || 0;


                        updateNotesList();
                        updateImageGallery();
                        renderMathInElement(document.getElementById('summaryContent'));
                        renderMathInElement(document.getElementById('notesList'));
                        saveStateToLocalStorage(); // Save the imported state

                        // Load the video after import. Seeking will happen in onPlayerReady.
                        if(currentVideoUrl) {
                            setTimeout(() => loadVideo(currentVideoUrl), 100);
                        } else {
                             // If no video URL in imported data, destroy existing player
                             if (player && typeof player.destroy === 'function') {
                                try { player.destroy(); player = null; } catch (e) { console.error("Error destroying player after import:", e); }
                            }
                             document.getElementById("videoContainer").innerHTML = '<p class="center-text" style="padding: 20px; color: #6c757d;">Ø£Ø¯Ø®Ù„ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ ÙŠÙˆØªÙŠÙˆØ¨ ÙˆØ§Ø¶ØºØ· "ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ" Ù„Ù„Ø¨Ø¯Ø¡.</p>';
                        }

                    } catch (error) {
                        console.error("Error importing data:", error);
                        alert("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù ØµØ­ÙŠØ­.");
                    }
                };
                reader.onerror = (error) => {
                    console.error("Error reading file:", error);
                    alert("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù.");
                };
                reader.readAsText(file);
            }
        };
        input.click();
    }

    // --- Toggle Floating Note Button ---
    function toggleFloatingNoteButton() {
        const button = document.getElementById('floatingNoteButton');
        if (button.style.display === 'none' || button.style.display === '') {
            button.style.display = 'block';
        } else {
            button.style.display = 'none';
        }
    }

    function toggleNotesSection() {
        const notesSection = document.querySelector('.notes-section');
        if (notesSection) {
            notesSection.scrollIntoView({ behavior: 'smooth' });
        }
    }

    // --- Download Page ---
     function downloadPage() {
        try {
            console.log("Preparing page HTML for saving...");
            const clonedDoc = document.documentElement.cloneNode(true);

            const clonedVideoUrlInput = clonedDoc.querySelector('#videoUrl');
            if(clonedVideoUrlInput) clonedVideoUrlInput.value = document.getElementById('videoUrl').value;

            const clonedTranscript = clonedDoc.querySelector('#transcriptInput');
            if (clonedTranscript) clonedTranscript.textContent = document.getElementById('transcriptInput').value;

            const clonedNoteText = clonedDoc.querySelector('#noteText');
            if(clonedNoteText) clonedNoteText.textContent = document.getElementById('noteText').value;

            const clonedSummaryContent = clonedDoc.querySelector('#summaryContent');
            if(clonedSummaryContent) clonedSummaryContent.innerHTML = document.getElementById('summaryContent').innerHTML;

             // Rebuild notes list in the cloned document (without extra buttons/handles)
             const clonedNotesList = clonedDoc.querySelector('#notesList');
             if(clonedNotesList) {
                  clonedNotesList.innerHTML = ''; // Clear clone
                  notes.forEach((note) => {
                    let listItem = document.createElement("li");
                    let contentHTML = `<b>[${formatTime(note.time)}]</b> `;
                    if (note.type === 'text') {
                         const textNode = document.createTextNode(note.text);
                         contentHTML += textNode.textContent; // Use textContent to avoid HTML issues
                    } else if (note.type === 'audio') {
                       contentHTML += `Ù…Ù„Ø§Ø­Ø¸Ø© ØµÙˆØªÙŠØ©: <audio controls src="${note.data || ''}"></audio>`;
                    }
                    listItem.innerHTML = contentHTML;
                    clonedNotesList.appendChild(listItem);
                  });
             }


             // Rebuild image gallery in the cloned document (simple images)
            const clonedImageGallery = clonedDoc.querySelector('#imageGallery');
            if(clonedImageGallery) {
                clonedImageGallery.innerHTML = '';
                lectureImages.forEach((imgData) => {
                    const imgElement = document.createElement('img'); imgElement.src = imgData.data; imgElement.alt = `ØµÙˆØ±Ø©`;
                    imgElement.style.cssText = 'display: inline-block; width: 120px; height: 120px; object-fit: cover; margin: 5px; border: 1px solid #ccc;';
                    clonedImageGallery.appendChild(imgElement);
                });
            }

             // Add current video time to the saved HTML (as a data attribute or hidden element)
             const savedTimeElement = clonedDoc.createElement('div');
             savedTimeElement.id = 'savedVideoPlaybackTime';
             savedTimeElement.setAttribute('data-time', (player && typeof player.getCurrentTime === 'function') ? player.getCurrentTime() : 0);
             savedTimeElement.style.display = 'none'; // Keep it hidden
             clonedDoc.body.appendChild(savedTimeElement);


            // Remove elements not needed in the saved file
            const selectorsToRemove = [
                '.floating-controls', '.floating-right-controls', '#recordNoteBtn', '#recordingStatus', '#imageUpload',
                'label[for="imageUpload"]', '#downloadPageBtn', '#notesList .reorder-buttons', '#notesList .note-buttons-container', // Remove note buttons/containers
                '#imageGallery .delete-img-btn', '.image-reorder-buttons', // Remove image reorder buttons
                '#imageModal', 'script[src*="https://www.youtube.com/iframe_api"]', '#playerStatus', '.search-box button', '.search-box input', '.search-box #searchResults',
                 '.speed-controls', '.button-container button:not(#downloadPageBtn):not(#exportBtn):not(#importBtn):not(#toggleFloatingNoteBtn)',
                 '#resetPageBtn',
                 'script:last-of-type'
            ];
             selectorsToRemove.forEach(selector => { clonedDoc.querySelectorAll(selector).forEach(el => el.remove()); });

             const head = clonedDoc.querySelector('head');
             if(head) {
                  const meta = document.createElement('meta'); meta.name = "description";
                  meta.content = "Ù†Ø³Ø®Ø© Ù…Ø­ÙÙˆØ¸Ø© Ù…Ù† ØµÙØ­Ø© Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª. ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ù„Ø§Ø­Ø¸Ø§Øª ÙˆØµÙˆØ± Ù…Ø¶Ù…Ù†Ø©."; head.appendChild(meta);
             }

             const clonedVideoContainer = clonedDoc.querySelector('#videoContainer');
             if(clonedVideoContainer) {
                 clonedVideoContainer.innerHTML = `<p class="center-text" style="padding: 20px; color: #6c757d;">Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø£ØµÙ„ÙŠ: <a href="${document.getElementById('videoUrl').value || '#'}" target="_blank">${document.getElementById('videoUrl').value || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</a></p>`;
                  // Add saved time indication
                 const savedTimeAttr = savedTimeElement.getAttribute('data-time');
                 if (savedTimeAttr && parseFloat(savedTimeAttr) > 0) {
                      const timeP = clonedDoc.createElement('p');
                      timeP.className = 'center-text';
                      timeP.style.color = '#6c757d';
                      timeP.innerText = `ØªÙ… Ø­ÙØ¸ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¹Ù†Ø¯ Ø§Ù„ÙˆÙ‚Øª: ${formatTime(parseFloat(savedTimeAttr))}`;
                      clonedVideoContainer.appendChild(timeP);
                 }
             }


            const finalHtml = "<!DOCTYPE html>\n" + clonedDoc.outerHTML;
            const blob = new Blob([finalHtml], { type: 'text/html;charset=UTF-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url;
            let filename = "lecture_page_saved.html";
            try {
                 const videoTitle = (player && typeof player.getVideoData === 'function' && player.getVideoData().title) ? player.getVideoData().title : '';
                 if (videoTitle) filename = videoTitle.replace(/[^a-z0-9\u0600-\u06FF\s]/gi, '_').replace(/\s+/g, '_').substring(0, 50) + ".html";
                 else if (currentVideoUrl) filename = 'video_notes_' + extractVideoID(currentVideoUrl) + '.html';
            } catch (e) { console.error("Error generating filename:", e); }
            a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            console.log("Page HTML saved as:", filename);
        } catch (error) {
            console.error("Error saving page HTML:", error);
            alert("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø­ÙØ¸ Ø§Ù„ØµÙØ­Ø© ÙƒÙ€ HTML.");
        }
    }


    // --- Reset Page Function ---
    function resetPage() {
        if (confirm("Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ ØªØ±ÙŠØ¯ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØµÙØ­Ø©ØŸ Ø³ÙŠØ¤Ø¯ÙŠ Ù‡Ø°Ø§ Ø¥Ù„Ù‰ Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª ÙˆØ§Ù„ØµÙˆØ± ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©.")) {
            resetAppState(true);
            notes = [];
            lectureImages = [];
            currentVideoUrl = '';
            savedVideoTime = 0; // Reset saved time

            document.getElementById("videoUrl").value = "";
            document.getElementById("noteText").value = "";
            document.getElementById("transcriptInput").value = "";
            document.getElementById("summaryContent").innerHTML = "ğŸ” Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ø®Øµ Ø¨Ø¹Ø¯.";
            document.getElementById("searchResults").innerHTML = "";

            updateNotesList();
            updateImageGallery();

            if (player && typeof player.destroy === 'function') {
                try { player.destroy(); player = null; } catch (e) { console.error("Error destroying player on reset:", e); }
            }
             document.getElementById("videoContainer").innerHTML = '<p class="center-text" style="padding: 20px; color: #6c757d;">Ø£Ø¯Ø®Ù„ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ ÙŠÙˆØªÙŠÙˆØ¨ ÙˆØ§Ø¶ØºØ· "ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ" Ù„Ù„Ø¨Ø¯Ø¡.</p>';

            localStorage.removeItem(LOCAL_STORAGE_KEY);
            console.log("LocalStorage state cleared.");

            stopPeriodicSave(); // Stop periodic saving on reset

            alert("âœ… ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØµÙØ­Ø© Ø¨Ù†Ø¬Ø§Ø­.");
        }
    }

    // --- Initial Load ---
     function resetAppState(clearAll = false) {
        document.getElementById("transcriptInput").value = "";
        document.getElementById("summaryContent").innerHTML = "ğŸ” Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ù…Ù„Ø®Øµ Ø¨Ø¹Ø¯.";
        document.getElementById("searchResults").innerHTML = "";
        document.getElementById("searchText").value = "";
        document.getElementById("clearSearchBtn").style.display = 'none';

        isPlaying = false; updatePlayPauseButton();
        console.log(`App state partially reset. Clear All (handled by resetPage): ${clearAll}.`);
    }


    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM ready.");
        loadStateFromLocalStorage();
        loadYouTubeAPI();
        setupImageHandling();
        updatePlayPauseButton();

        // Initial render of notes from loaded state
        // This is called in loadStateFromLocalStorage now
        // updateNotesList();

        // Check if the page was loaded from a saved HTML file with embedded time
        const savedTimeElement = document.getElementById('savedVideoPlaybackTime');
        if (savedTimeElement) {
             const time = parseFloat(savedTimeElement.getAttribute('data-time'));
             if (!isNaN(time) && time > 0) {
                  savedVideoTime = time;
                  console.log(`Loaded saved video time from HTML: ${formatTime(savedVideoTime)}`);
                  // The video will be loaded and seeked in loadStateFromLocalStorage / onPlayerReady
             }
        }
    });

    // --- Add confirmation message before leaving/refreshing ---
    window.addEventListener('beforeunload', function (e) {
        // Note: You cannot customize the message shown by the browser
        // The browser displays a generic message like "Changes you made may not be saved."

        // To trigger the confirmation prompt, you need to cancel the event
        e.preventDefault();
        // Chrome requires returnValue to be set
        e.returnValue = '';
    });

  </script>
</body>
</html>
